// dllmain.cpp : Defines the entry point for the DLL application.
#include "pch.h"
#include "Entity.h"
#include "offsets.h"
#include "Hooks.h"
#include "mem.h"

#define makeOutputHex(txt) std::hex << txt << std::dec

//TODO: do integrity check of server.dll for updates!

//retrieves the specified module handle. use wchar because we are in unicode and it is GetModuleHandleW!
uintptr_t modBase = (uintptr_t)(GetModuleHandle(L"server.dll"));
BYTE* getEntities = (BYTE*)(modBase + ENTITY_LIST_HOOK);
size_t* numOfEntities = (size_t*)(modBase + ENTITY_COUNT);
Entity* localPlayer = *(Entity**)(modBase + LOCAL_ENTITY);
EntityList entityList;
std::vector<Hooks::Hook> hooks;
uintptr_t gateway;

bool bTeleport{};

//GENERATED BY IDA
typedef int(__fastcall* entityIterator)(void*, void*, int);//define our hook function

entityIterator oGetEntity;

entityIterator hkGetEntity(void* _this, void* not_edx, int a2)
{
	std::cout << _this << " " << a2 << std::endl;
	//if ((_this[0xEC] + ENTITY_STEP * a2)) {
	//	Entity* ent = *(Entity**)(_this[0xEC] + ENTITY_STEP * a2);
	//	std::cout << "Entitity " << a2 << " health: " << ent->health << std::endl;
	//}

	size_t i = 10;
	numOfEntities = &i;
	/*
	if (entityList.entities.size() <= *numOfEntities)
		entityList.entities.push_back(*(Entity**)(_this[0xEC] + ENTITY_STEP * a2));
	*/
	return (entityIterator)oGetEntity(_this, not_edx, a2);
}

bool isEntValid(Entity* ent) {
	if (ent) {
		if (ent != localPlayer) {
			if (ent->team != localPlayer->team) {
				if (ent->health > 0)
					return true;
			}
		}
	}
	return false;
}

DWORD WINAPI Main(HMODULE hModule) {
	AllocConsole();
	FILE* f;
	freopen_s(&f, "CONOUT$", "w", stdout);//stdout is a handle with write permissions to the console stream
	using std::cout, std::endl;

	cout << "Protowave.dev CSGO public version" << endl;

	//hook Endscene later to make our hack loop
	while (true) {
		if (GetAsyncKeyState(VK_END) & 1)
		{
			//unhooking stuff
			break;
		}
		if (GetAsyncKeyState(VK_F1) & 1)
		{
			bTeleport = !bTeleport;
			if (bTeleport) {
				hooks.emplace_back(getEntities, getEntities, 6);
				gateway = (hooks[0].TrampHook32((BYTE*)hkGetEntity));//(entityIterator)
				oGetEntity = (entityIterator)gateway;
				cout << "oGetEntity: 0x" << makeOutputHex(oGetEntity) << endl;
				cout << "Hooked function getEntitity 0x" << makeOutputHex(modBase + ENTITY_LIST_FUNC) << endl;
			}
			else {
				cout << "Unhooked GetEntity!" << endl;
				hooks[0].unTrampHook32((BYTE*)oGetEntity, 6);

				//re-assign the original address to the original function to avoid crashes in the hooked function at return
				oGetEntity = (entityIterator)(hooks[0].getHooked());
			}
		}

		if (GetAsyncKeyState(VK_F2) & 1)
		{
			cout << "Got " << entityList.entities.size() << " " << numOfEntities << " entities" << endl;
			size_t num = 10;
			numOfEntities = &num;
			if (numOfEntities > 0) {
				for (DWORD i{}; i < *numOfEntities; i++)
				{
					Entity* ent = entityList.entities[i];
					if (isEntValid(ent)) {
						ent->health = 0;
						//ent->Position.x = localPlayer->Position.x + 1;
						//ent->Position.y = localPlayer->Position.x + 1;
						//ent->Position.z = localPlayer->Position.x + 1;
					}
				}
			}
		}
	}
	fclose(f);
	FreeConsole();
	FreeLibraryAndExitThread(hModule, 0);
}

BOOL APIENTRY DllMain(HMODULE hModule,
	DWORD  ul_reason_for_call,
	LPVOID lpReserved
)
{
	HANDLE hThread = nullptr;
	switch (ul_reason_for_call)
	{
	case DLL_PROCESS_ATTACH:
		hThread = CreateThread(nullptr, NULL, (LPTHREAD_START_ROUTINE)Main, hModule, 0, nullptr);
		if (hThread) CloseHandle(hThread);
	case DLL_THREAD_ATTACH:
	case DLL_THREAD_DETACH:
	case DLL_PROCESS_DETACH:
		break;
	}
	return TRUE;
}